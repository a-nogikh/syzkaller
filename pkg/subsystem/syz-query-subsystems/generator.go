// Copyright 2023 syzkaller project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/google/syzkaller/pkg/serializer"
	"github.com/google/syzkaller/pkg/subsystem/entity"
)

func generateSubsystemsFile(name string, subsystems []*entity.Subsystem) ([]byte, error) {
	// Drop subsystems without a name.
	list := []*entity.Subsystem{}
	for _, entry := range subsystems {
		if entry.Name == "" {
			log.Printf("skipping a subsystem with no name (lists: %#v, rules: %#v)", entry.Lists, entry.PathRules)
			continue
		}
		// Clean parents.
		newParents := []*entity.Subsystem{}
		for _, p := range entry.Parents {
			if p.Name != "" {
				newParents = append(newParents, p)
			}
		}
		entry.Parents = newParents
		list = append(list, entry)
	}

	// Sort subsystems by name to keep output consistent.
	sort.Slice(list, func(i, j int) bool { return list[i].Name < list[j].Name })

	// Sort path rules to keep output consistent.
	for _, entity := range list {
		sort.Slice(entity.PathRules, func(i, j int) bool {
			a, b := entity.PathRules[i], entity.PathRules[j]
			if a.IncludeRegexp != b.IncludeRegexp {
				return a.IncludeRegexp < b.IncludeRegexp
			}
			return a.ExcludeRegexp < b.ExcludeRegexp
		})
	}

	// Set names first -- we'll need them for filling in the Parents array.
	objToName := map[*entity.Subsystem]string{}
	for _, entry := range list {
		varName := makeVarRegexp.ReplaceAllString(strings.ToLower(entry.Name), "")
		if varName == "" {
			return nil, fmt.Errorf("failed to get a var name for %#v", entry.Name)
		}
		objToName[entry] = varName
	}

	// Prepare the template data.
	vars := &templateVars{
		Name:        name,
		PackageName: strings.ReplaceAll(name, "_", ""),
		Hierarchy:   hierarchyList(list),
	}
	for _, entry := range list {
		varName := objToName[entry]
		// The serializer does not understand parent references and just prints all the
		// nested structures.
		// Therefore we call it separately for the fields it can understand.
		parents := []string{}
		for _, p := range entry.Parents {
			parents = append(parents, objToName[p])
		}
		sort.Strings(parents)
		subsystem := &templateSubsystem{
			VarName:   varName,
			Name:      serializer.WriteString(entry.Name),
			PathRules: serializer.WriteString(entry.PathRules),
			Lists:     serializer.WriteString(entry.Lists),
			Parents:   parents,
		}
		// Some of the records are mostly empty.
		if len(entry.Maintainers) > 0 {
			subsystem.Maintainers = serializer.WriteString(entry.Maintainers)
		}
		if len(entry.Syscalls) > 0 {
			subsystem.Syscalls = serializer.WriteString(entry.Syscalls)
		}
		vars.List = append(vars.List, subsystem)
	}
	tmpl, err := template.New("source").Parse(fileTemplate)
	if err != nil {
		return nil, err
	}
	var b bytes.Buffer
	if err = tmpl.Execute(&b, vars); err != nil {
		return nil, err
	}
	return format.Source(b.Bytes())
}

func hierarchyList(list []*entity.Subsystem) []string {
	children := map[*entity.Subsystem][]*entity.Subsystem{}
	for _, entry := range list {
		for _, p := range entry.Parents {
			children[p] = append(children[p], entry)
		}
	}
	ret := []string{}
	var dfs func(*entity.Subsystem, string)
	dfs = func(entry *entity.Subsystem, prefix string) {
		ret = append(ret, fmt.Sprintf("%s- %s", prefix, entry.Name))
		for _, child := range children[entry] {
			dfs(child, prefix+"  ")
		}
	}
	for _, entity := range list {
		if len(entity.Parents) == 0 {
			dfs(entity, "")
		}
	}
	return ret
}

var makeVarRegexp = regexp.MustCompile(`[^\w]|^([^a-z]+)`)

type templateSubsystem struct {
	VarName     string
	Name        string
	Syscalls    string
	PathRules   string
	Lists       string
	Maintainers string
	Parents     []string
}

type templateVars struct {
	Name        string
	PackageName string
	List        []*templateSubsystem
	Hierarchy   []string
}

const fileTemplate = `// AUTOGENERATED FILE

package {{.PackageName}}

import . "github.com/google/syzkaller/pkg/subsystem/entity"
import "github.com/google/syzkaller/pkg/subsystem"

func init() {
  subsystem.RegisterList("{{.Name}}", subsystems)
}

// The subsystem list:
{{- range .Hierarchy}}
// {{.}}
{{- end}}

var subsystems = []*Subsystem{
{{range .List}} {{.VarName}}, {{- end}}
}

// Subsystem info.
{{range .List}}
var {{.VarName}} = &Subsystem{
 Name: {{.Name}},
{{- if .Syscalls}}
 Syscalls: {{.Syscalls}},
{{- end}}
 Lists: {{.Lists}},
{{- if .Maintainers}}
 Maintainers: {{.Maintainers}},
{{- end}}
 Parents: []*Subsystem{ {{range .Parents}} {{.}}, {{end}} },
 PathRules: {{.PathRules}},
}
{{end}}
`
